# File: .github/workflows/cd.yml
name: CD to GKE (Build, Push, Deploy, Stress Test)


on:
  push:
    branches:
      - wk7 # Trigger on push to the new wk7 branch
    paths:
      - 'Dockerfile'
      - 'app.py'
      - 'requirements.txt'
      - 'k8s/**'


env:
  # Define variables using GitHub Secrets configured by the user
  GCP_PROJECT: \${{ secrets.GCP_PROJECT }}
  GAR_REGION: \${{ secrets.GAR_REGION }}
  GAR_REPO: \${{ secrets.GAR_REPO }}
  GKE_CLUSTER: \${{ secrets.GKE_CLUSTER }}
  GKE_ZONE: \${{ secrets.GKE_ZONE }}
  IMAGE_NAME: iris-api
  K8S_DEPLOYMENT_FILE: k8s/deployment.yaml
  K8S_HPA_FILE: k8s/hpa-scenario1.yaml # Use Scenario 1 HPA for initial test


jobs:
  build-push-deploy:
    runs-on: ubuntu-latest
    
    steps:
    - name: â¬‡ï¸ Checkout Repository
      uses: actions/checkout@v4


    - name: ðŸ”‘ Authenticate to Google Cloud
      uses: google-github-actions/auth@v2
      with:
        credentials_json: \${{ secrets.GCP_SA_KEY }}


    - name: âš™ï¸ Set up Cloud SDK and kubectl
      uses: google-github-actions/setup-gcloud@v2
      with:
        install_components: 'kubectl'
        
    - name: ðŸ—ï¸ Build and Push Docker Image
      run: |
        IMAGE_TAG=\${{ github.sha }}
        IMAGE_URI=\${{ env.GAR_REGION }}-docker.pkg.dev/\${{ env.GCP_PROJECT }}/\${{ env.GAR_REPO }}/\${{ env.IMAGE_NAME }}:\${IMAGE_TAG}
        
        gcloud auth configure-docker \${{ env.GAR_REGION }}-docker.pkg.dev


        docker build -t \${IMAGE_URI} .


        echo "Pushing \${IMAGE_URI}..."
        docker push \${IMAGE_URI}
        echo "IMAGE_URI=\${IMAGE_URI}" >> \$GITHUB_ENV
    
    - name: â˜¸ï¸ Deploy to GKE (Deployment and Service)
      run: |
        # Get Kubeconfig Credentials
        gcloud container clusters get-credentials \${{ env.GKE_CLUSTER }} --zone \${{ env.GKE_ZONE }}


        # Substitute the image path
        sed -i "s|us-central1-docker.pkg.dev/global-student-472816-d6/iris-repo/iris-api:latest|${{ env.IMAGE_URI }}|g" ${{ env.K8S_DEPLOYMENT_FILE }}


        # Apply Deployment and Service
        kubectl apply -f \${{ env.K8S_DEPLOYMENT_FILE }}
        
        # Wait for Deployment Rollout
        kubectl rollout status deployment/iris-api-deployment --timeout=5m
        
    - name: ðŸ“ˆ Apply Horizontal Pod Autoscaler (HPA)
      run: |
        # Apply the HPA manifest for Scenario 1 (max_pods: 3)
        kubectl apply -f \${{ env.K8S_HPA_FILE }}
        echo "HPA applied. Initial status:"
        kubectl get hpa
        
    - name: ðŸ› ï¸ Install wrk for Stress Testing
      run: |
        # wrk is a high-performance HTTP benchmarking tool
        sudo apt-get update -qq && sudo apt-get install -y wrk


    - name: ðŸŒ Get External Load Balancer IP
      id: get_ip
      run: |
        # Use a loop to wait for the LoadBalancer IP to be provisioned
        EXTERNAL_IP=""
        for i in {1..30}; do
          # Use awk to filter the first non-pending IP address
          EXTERNAL_IP=\$(kubectl get service iris-api-service -o json | jq -r '.status.loadBalancer.ingress[0].ip' 2>/dev/null)
          if [ -n "\$EXTERNAL_IP" ] && [ "\$EXTERNAL_IP" != "null" ]; then
            echo "::set-output name=service_ip::\$EXTERNAL_IP"
            echo "Service IP: \$EXTERNAL_IP"
            break
          fi
          echo "Waiting for external IP... (Attempt \$i/30)"
          sleep 10
        done
        if [ -z "\$EXTERNAL_IP" ] || [ "\$EXTERNAL_IP" == "null" ]; then
          echo "Failed to get external IP after 5 minutes."
          # Continue to cleanup step, but warn
          exit 0
        fi


    - name: ðŸš€ SCENARIO 1: Stress Test (Observe Autoscaling to 3 Pods)
      env:
        SERVICE_IP: \${{ steps.get_ip.outputs.service_ip }}
      run: |
        if [ "\${{ steps.get_ip.outputs.service_ip }}" == "" ]; then
            echo "Skipping stress test due to missing external IP."
            exit 0
        fi


        echo "--- SCENARIO 1: Autoscaling Test (Target Max 3 Pods) ---"
        echo "Initial Pods and HPA Status:"
        kubectl get pods -l app=iris-api
        kubectl get hpa iris-api-hpa
        
        # Run wrk: 1000 connections, 20 threads, for 60 seconds
        echo "Starting wrk stress test for 60 seconds (1000 connections/20 threads)..."
        wrk -t20 -c1000 -d60s http://\${SERVICE_IP}/


        echo "--- Mid-Test Status (Wait for 2 min for HPA to react) ---"
        sleep 120 
        
        echo "Post-Stress Pod Status (Should see 2 or 3 Pods running):"
        kubectl get pods -l app=iris-api
        
        echo "Post-Stress HPA Status:"
        kubectl get hpa iris-api-hpa
        
    - name: ðŸ›‘ Cleanup HPA and Deployment
      # This step always runs to clean up resources
      if: always()
      run: |
        gcloud container clusters get-credentials \${{ env.GKE_CLUSTER }} --zone \${{ env.GKE_ZONE }} --quiet


        echo "Cleaning up HPA..."
        kubectl delete hpa iris-api-hpa --ignore-not-found=true
        
        echo "Scaling down deployment to 0..."
        kubectl scale deployment iris-api-deployment --replicas=0
        
        echo "Cleanup complete."
